package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"github.com/stackgen-cli/envmerge/internal/resolver"
	"github.com/stackgen-cli/envmerge/internal/reporter"
)

var (
	outputFile    string
	outputFormat  string
	includeOSEnv  bool
	serviceName   string
	strictMode    bool
	compareWith   string
)

var scanCmd = &cobra.Command{
	Use:   "scan [path]",
	Short: "Scan and resolve environment variables",
	Long: `Scan the current directory (or specified path) for environment files
and Docker Compose configurations, then resolve the final value of each
environment variable showing the full precedence chain.

Use --include-os-env to include system environment variables in resolution.
Use --service to filter to a specific service's variables.
Use --strict to fail if any variables are referenced but not defined.
Use --compare to compare with another environment directory.

Examples:
  envmerge scan
  envmerge scan ./myproject
  envmerge scan --include-os-env
  envmerge scan --service api
  envmerge scan --strict
  envmerge scan --compare ./staging`,
	Args: cobra.MaximumNArgs(1),
	RunE: runScan,
}

func init() {
	scanCmd.Flags().StringVarP(&outputFile, "output", "o", "", "Write resolved env to file (e.g., .env.effective)")
	scanCmd.Flags().StringVarP(&outputFormat, "format", "f", "text", "Output format: text, json, markdown")
	scanCmd.Flags().BoolVar(&includeOSEnv, "include-os-env", false, "Include OS environment variables in resolution")
	scanCmd.Flags().StringVar(&serviceName, "service", "", "Filter to specific service's variables")
	scanCmd.Flags().BoolVar(&strictMode, "strict", false, "Fail if any variables are undefined")
	scanCmd.Flags().StringVar(&compareWith, "compare", "", "Compare with another environment directory")
}

func runScan(cmd *cobra.Command, args []string) error {
	path := "."
	if len(args) > 0 {
		path = args[0]
	}

	// Build options
	opts := resolver.Options{
		IncludeOSEnv: includeOSEnv,
		ServiceName:  serviceName,
		StrictMode:   strictMode,
	}

	// Resolve all environment variables
	result, err := resolver.ResolveWithOptions(path, opts)
	if err != nil {
		return fmt.Errorf("resolution failed: %w", err)
	}

	// Handle compare mode
	if compareWith != "" {
		secondResult, err := resolver.ResolveWithOptions(compareWith, opts)
		if err != nil {
			return fmt.Errorf("failed to resolve comparison path: %w", err)
		}

		comparison := resolver.Compare(result, secondResult)
		fmt.Println(resolver.FormatCompare(path, compareWith, comparison))
		return nil
	}

	// Output based on format
	switch outputFormat {
	case "json":
		output, err := reporter.FormatJSON(result)
		if err != nil {
			return err
		}
		fmt.Println(output)
	case "markdown":
		output, err := reporter.FormatMarkdown(result)
		if err != nil {
			return err
		}
		fmt.Println(output)
	default:
		output, err := reporter.FormatText(result)
		if err != nil {
			return err
		}
		fmt.Println(output)
	}

	// Write effective env file if requested
	if outputFile != "" {
		if err := writeEffectiveEnv(result, outputFile); err != nil {
			return fmt.Errorf("failed to write output: %w", err)
		}
		fmt.Printf("\nâœ… Written to %s\n", outputFile)
	}

	return nil
}

func writeEffectiveEnv(result *resolver.Resolution, path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintln(f, "# Generated by envmerge - effective environment values")
	fmt.Fprintln(f, "# This file shows the final resolved values after all overrides")
	fmt.Fprintln(f, "")

	for _, v := range result.Variables {
		if v.FinalValue != "" {
			fmt.Fprintf(f, "%s=%s\n", v.Name, v.FinalValue)
		}
	}

	return nil
}
